[
  {
    "id": "games",
    "title": "Games & Animations",
    "summary": "Interactive visualizations to build deep intuition.",
    "itemCount": 10,
    "items": [
      {
        "id": "binary-search-game",
        "title": "Binary Search — Guessing Game",
        "difficulty": "easy",
        "brief": "Find the hidden number with as few guesses as possible."
      },
      {
        "id": "bfs-maze",
        "title": "BFS Maze — Shortest Path",
        "difficulty": "easy-medium",
        "brief": "Place walls and watch BFS explore and find shortest path."
      },
      {
        "id": "heap-sandbox",
        "title": "Heap Sandbox — Push/Pop",
        "difficulty": "easy-medium",
        "brief": "Interact with a min-heap: push values, pop min, and watch heap order."
      },
      {
        "id": "sorting-race",
        "title": "Sorting Race — Visualize Algorithms",
        "difficulty": "easy-medium",
        "brief": "Watch sorting algorithms race on the same array."
      },
      {
        "id": "uf-playground",
        "title": "Union-Find Playground",
        "difficulty": "easy-medium",
        "brief": "Add unions and watch components merge with path compression."
      },
      {
        "id": "dp-grid",
        "title": "DP Grid — Unique Paths",
        "difficulty": "easy",
        "brief": "Fill a DP table for unique paths with obstacles."
      },
      {
        "id": "kmp-explorer",
        "title": "KMP Explorer — Prefix Function",
        "difficulty": "medium",
        "brief": "Step through building the prefix (LPS) table and matching."
      },
      {
        "id": "aho-explorer",
        "title": "Aho–Corasick Explorer — Multi-Pattern",
        "difficulty": "hard",
        "brief": "Build automaton from patterns and step through the text to see matches."
      },
      {
        "id": "dinic-flow",
        "title": "Dinic Flow — Levels & Blocking Flow",
        "difficulty": "hard",
        "brief": "See level graph construction and augment along blocking flows."
      },
      {
        "id": "hld-play",
        "title": "Heavy-Light Decomposition — Path Queries",
        "difficulty": "hard",
        "brief": "Decompose a tree, then query paths by segment ranges."
      }
    ]
  },
  {
    "id": "complexity",
    "title": "Complexity Primer",
    "summary": "Big-O basics, loop patterns, binary search, and core cost models.",
    "itemCount": 6,
    "items": [
      {
        "id": "big-o-basics",
        "title": "Big-O Basics",
        "difficulty": "easy",
        "brief": "Understand how input size drives time and space growth."
      },
      {
        "id": "nested-loops",
        "title": "Loop Patterns: Nested vs Logarithmic",
        "difficulty": "easy-medium",
        "brief": "Contrast O(n^2) nested loops with O(n log n) patterns."
      },
      {
        "id": "binary-search-primer",
        "title": "Binary Search (Complexity Focus)",
        "difficulty": "easy",
        "brief": "Use binary search to find a target; reason about O(log n)."
      },
      {
        "id": "amortized-dynamic-array",
        "title": "Amortized Analysis: Dynamic Array Push",
        "difficulty": "easy-medium",
        "brief": "Why push is O(1) amortized under doubling reallocation."
      },
      {
        "id": "master-theorem",
        "title": "Master Theorem (Divide & Conquer)",
        "difficulty": "medium-hard",
        "brief": "Classify T(n) = a T(n/b) + Θ(n^k log^p n)."
      },
      {
        "id": "ds-costs",
        "title": "Data Structure Operation Costs",
        "difficulty": "easy",
        "brief": "Know common operation complexities to guide choices."
      }
    ]
  },
  {
    "id": "complexity",
    "title": "Complexity Primer",
    "summary": "Big-O basics, loop patterns, binary search, and core cost models.",
    "itemCount": 6,
    "items": [
      {
        "id": "big-o-basics",
        "title": "Big-O Basics",
        "difficulty": "easy",
        "brief": "Understand how input size drives time and space growth."
      },
      {
        "id": "nested-loops",
        "title": "Loop Patterns: Nested vs Logarithmic",
        "difficulty": "easy-medium",
        "brief": "Contrast O(n^2) nested loops with O(n log n) patterns."
      },
      {
        "id": "binary-search-primer",
        "title": "Binary Search (Complexity Focus)",
        "difficulty": "easy",
        "brief": "Use binary search to find a target; reason about O(log n)."
      },
      {
        "id": "amortized-dynamic-array",
        "title": "Amortized Analysis: Dynamic Array Push",
        "difficulty": "easy-medium",
        "brief": "Why push is O(1) amortized under doubling reallocation."
      },
      {
        "id": "master-theorem",
        "title": "Master Theorem (Divide & Conquer)",
        "difficulty": "medium-hard",
        "brief": "Classify T(n) = a T(n/b) + Θ(n^k log^p n)."
      },
      {
        "id": "ds-costs",
        "title": "Data Structure Operation Costs",
        "difficulty": "easy",
        "brief": "Know common operation complexities to guide choices."
      }
    ]
  },
  {
    "id": "arrays-pointers",
    "title": "Arrays & Two Pointers",
    "summary": "Classic scanning patterns: opposite ends, fast/slow, partitioning.",
    "itemCount": 4,
    "items": [
      {
        "id": "two-sum",
        "title": "Two Pointers: Two Sum (Sorted)",
        "difficulty": "easy",
        "brief": "Find two numbers adding to target in a sorted array."
      },
      {
        "id": "longest-substring-no-repeat",
        "title": "Sliding Window: Longest Substring Without Repeating",
        "difficulty": "medium",
        "brief": "Find length of longest substring without repeating characters."
      },
      {
        "id": "three-sum",
        "title": "Two Pointers: 3Sum",
        "difficulty": "medium",
        "brief": "Return all unique triplets that sum to zero."
      },
      {
        "id": "min-window",
        "title": "Sliding Window: Minimum Window Substring",
        "difficulty": "hard",
        "brief": "Smallest substring of s that contains all chars of t."
      }
    ]
  },
  {
    "id": "searching",
    "title": "Searching & Sorting",
    "summary": "Binary search patterns and reasoning about invariants.",
    "itemCount": 1,
    "items": [
      {
        "id": "binary-search-lb",
        "title": "Binary Search: Lower Bound",
        "difficulty": "easy",
        "brief": "Find first index >= target in sorted array."
      }
    ]
  },
  {
    "id": "intervals",
    "title": "Intervals",
    "summary": "Sorting-based merging and sweep-line reasoning.",
    "itemCount": 1,
    "items": [
      {
        "id": "merge-intervals",
        "title": "Merge Intervals",
        "difficulty": "medium",
        "brief": "Merge overlapping intervals after sorting by start."
      }
    ]
  },
  {
    "id": "heaps-selection",
    "title": "Heaps & Selection",
    "summary": "Priority queues to pick extremes efficiently.",
    "itemCount": 2,
    "items": [
      {
        "id": "kth-largest",
        "title": "Kth Largest via Min-Heap",
        "difficulty": "medium",
        "brief": "Maintain a size-k min-heap while scanning."
      },
      {
        "id": "top-k-frequent",
        "title": "Top K Frequent Elements",
        "difficulty": "medium",
        "brief": "Return k elements by frequency with deterministic ordering."
      }
    ]
  },
  {
    "id": "dp",
    "title": "Dynamic Programming",
    "summary": "Optimal substructure, overlapping subproblems, transitions.",
    "itemCount": 4,
    "items": [
      {
        "id": "coin-change",
        "title": "DP: Coin Change (Min Coins)",
        "difficulty": "medium",
        "brief": "Min coins to make amount using unlimited coins."
      },
      {
        "id": "lis-length",
        "title": "DP: Longest Increasing Subsequence (O(n log n))",
        "difficulty": "medium-hard",
        "brief": "Patience sorting with tails array."
      },
      {
        "id": "edit-distance",
        "title": "DP: Edit Distance (Levenshtein)",
        "difficulty": "medium-hard",
        "brief": "Min operations (insert, delete, replace) to convert word1 to word2."
      },
      {
        "id": "word-break",
        "title": "DP: Word Break",
        "difficulty": "medium",
        "brief": "Decide if string can be segmented into dictionary words."
      }
    ]
  },
  {
    "id": "greedy",
    "title": "Greedy Strategies",
    "summary": "Locally optimal moves for global optimum.",
    "itemCount": 1,
    "items": [
      {
        "id": "jump-game-2",
        "title": "Greedy: Jump Game II",
        "difficulty": "medium",
        "brief": "Minimum jumps to reach end of array."
      }
    ]
  },
  {
    "id": "stacks",
    "title": "Stacks",
    "summary": "Parentheses validation and monotone stack patterns.",
    "itemCount": 2,
    "items": [
      {
        "id": "valid-parens",
        "title": "Valid Parentheses",
        "brief": "Check if brackets string is valid."
      },
      {
        "id": "daily-temps",
        "title": "Daily Temperatures (Monotonic Stack)",
        "difficulty": "medium",
        "brief": "For each day, wait until a warmer temperature."
      }
    ]
  },
  {
    "id": "graphs-bfs-dijkstra",
    "title": "Graphs: BFS & Dijkstra",
    "summary": "Shortest paths in un/weighted graphs.",
    "itemCount": 2,
    "items": [
      {
        "id": "bfs-shortest",
        "title": "BFS: Shortest Path (Unweighted)",
        "difficulty": "easy-medium",
        "brief": "Find shortest path length between two nodes."
      },
      {
        "id": "dijkstra",
        "title": "Dijkstra: Single-Source Shortest Paths",
        "difficulty": "medium-hard",
        "brief": "Non-negative edge weights with priority queue."
      }
    ]
  },
  {
    "id": "graphs-dag",
    "title": "Graphs: DAG & Topo",
    "summary": "Topological ordering and cycle detection for scheduling.",
    "itemCount": 1,
    "items": [
      {
        "id": "course-schedule",
        "title": "Course Schedule (canFinish)",
        "difficulty": "medium",
        "brief": "Detect cycles with Kahn’s algorithm (BFS topological sort)."
      }
    ]
  },
  {
    "id": "matrix-dfs",
    "title": "Matrix DFS/BFS",
    "summary": "Grid traversal and connected components.",
    "itemCount": 1,
    "items": [
      {
        "id": "num-islands",
        "title": "Number of Islands",
        "difficulty": "medium",
        "brief": "Count connected components of 1s using DFS/BFS."
      }
    ]
  },
  {
    "id": "union-find",
    "title": "Disjoint Set (Union-Find)",
    "summary": "Connectivity and components with near-constant-time ops.",
    "itemCount": 1,
    "items": [
      {
        "id": "uf-components",
        "title": "Union-Find: Count Components",
        "difficulty": "medium",
        "brief": "Return number of connected components in undirected graph."
      }
    ]
  },
  {
    "id": "binary-search-answer",
    "title": "Binary Search on Answer",
    "summary": "Optimize threshold by searching feasible space.",
    "itemCount": 1,
    "items": [
      {
        "id": "ship-within-days",
        "title": "Binary Search on Answer: Ship Packages",
        "difficulty": "medium",
        "brief": "Min capacity to ship within D days."
      }
    ]
  },
  {
    "id": "bit-manip",
    "title": "Bit Manipulation",
    "summary": "XOR, masks, and bitwise tricks.",
    "itemCount": 1,
    "items": [
      {
        "id": "single-number",
        "title": "Bit Manipulation: Single Number",
        "difficulty": "easy",
        "brief": "Find the element that appears once when others appear twice."
      }
    ]
  },
  {
    "id": "hashing",
    "title": "Hashing & Strings",
    "summary": "Grouping, counters, and maps.",
    "itemCount": 1,
    "items": [
      {
        "id": "group-anagrams",
        "title": "Group Anagrams",
        "difficulty": "medium",
        "brief": "Group words that are anagrams; deterministic order."
      }
    ]
  },
  {
    "id": "trees",
    "title": "Trees & BST",
    "summary": "Invariants on structure and traversals.",
    "itemCount": 2,
    "items": [
      {
        "id": "validate-bst",
        "title": "Validate Binary Search Tree",
        "difficulty": "easy",
        "brief": "Check BST property using bounds."
      },
      {
        "id": "level-order",
        "title": "Binary Tree Level Order Traversal",
        "difficulty": "easy",
        "brief": "Return values level by level from root."
      }
    ]
  },
  {
    "id": "trees-ranges",
    "title": "Trees & Ranges",
    "summary": "Fenwick/Segment Trees and Sparse Table for queries.",
    "itemCount": 3,
    "items": [
      {
        "id": "fenwick-tree",
        "title": "Fenwick Tree (Binary Indexed Tree)",
        "difficulty": "medium",
        "brief": "Point updates and prefix/range sums in O(log n)."
      },
      {
        "id": "segment-tree",
        "title": "Segment Tree (Range Sum, Point Update)",
        "difficulty": "medium-hard",
        "brief": "Explicit tree supporting range sum queries and point updates."
      },
      {
        "id": "sparse-table",
        "title": "Sparse Table (RMQ, static)",
        "difficulty": "medium",
        "brief": "O(n log n) build, O(1) min query on static array."
      }
    ]
  },
  {
    "id": "strings",
    "title": "String Algorithms",
    "summary": "Linear-time pattern matching and preprocessing.",
    "itemCount": 2,
    "items": [
      {
        "id": "kmp",
        "title": "KMP String Matching",
        "difficulty": "medium-hard",
        "brief": "Linear-time search using prefix-function (pi/LPS)."
      },
      {
        "id": "z-function",
        "title": "Z-Algorithm",
        "difficulty": "medium",
        "brief": "Linear-time prefix match lengths for every position."
      }
    ]
  },
  {
    "id": "graphs-advanced",
    "title": "Graphs: Advanced",
    "summary": "SCC, MST (Kruskal), and LCA (binary lifting).",
    "itemCount": 3,
    "items": [
      {
        "id": "scc-kosaraju",
        "title": "Strongly Connected Components (Kosaraju)",
        "difficulty": "medium-hard",
        "brief": "Two-pass DFS on graph and its transpose."
      },
      {
        "id": "mst-kruskal",
        "title": "Minimum Spanning Tree (Kruskal)",
        "difficulty": "medium",
        "brief": "Sort edges by weight, add if they connect different components."
      },
      {
        "id": "lca-binary-lifting",
        "title": "LCA via Binary Lifting",
        "difficulty": "medium-hard",
        "brief": "Precompute 2^k ancestors and depths to answer LCA queries."
      }
    ]
  },
  {
    "id": "flows-cuts",
    "title": "Flows & Cuts",
    "summary": "Max flow via Edmonds–Karp for small graphs.",
    "itemCount": 1,
    "items": [
      {
        "id": "max-flow-ek",
        "title": "Max Flow (Edmonds–Karp)",
        "difficulty": "hard",
        "brief": "BFS on residual graph to find augmenting paths (O(VE^2))."
      }
    ]
  },
  {
    "id": "number-theory",
    "title": "Number Theory",
    "summary": "Fast exponentiation and matrix exponentiation.",
    "itemCount": 2,
    "items": [
      {
        "id": "fast-pow",
        "title": "Fast Power (Modular Exponentiation)",
        "difficulty": "easy",
        "brief": "Binary exponentiation in O(log b)."
      },
      {
        "id": "fib-mat-expo",
        "title": "Matrix Exponentiation: Fibonacci",
        "difficulty": "medium",
        "brief": "Compute F(n) using fast exponentiation of 2x2 matrices."
      }
    ]
  }
]
